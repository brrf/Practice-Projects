<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Data Structures</title>
</head>
<body>


<script>
	
class Node {
	constructor(value) {
		this.value = value;
		this.next = null
   }
}
        
class LinkedList {
	constructor (list) {
		this.head = null;
		if (list) {
			list.forEach(value => {
				this.append(value)
			})
		}
	};

	append(value) {
		if (this.head === null) {
			this.head = new Node(value)
			return;
		};
		let node = this.head;
		while (node.next) {
			node = node.next
		};

		node.next = new Node(value)
		return;
	}
}

function merge(list1, list2) {
	let merged = new LinkedList();
	//if either list is null return the other list
	if (!list1) return list2;
	if (!list2) return list1;

	//start with each lists head
	let currentNode1 = list1.head;
	let currentNode2 = list2.head;


	//while either currentNode is not null append the lowest current value to merged
	while (currentNode1 || currentNode2) {
		if (!currentNode1) {
			merged.append(currentNode2.value);
			currentNode2 = currentNode2.next;
		} else if (!currentNode2) {
			merged.append(currentNode1.value);
			currentNode1 = currentNode1.next;
		} else if (currentNode1.value <= currentNode2.value) {
			merged.append(currentNode1.value);
			currentNode1 = currentNode1.next;
		} else {
			merged.append(currentNode2.value);
			currentNode2 = currentNode2.next;
		}
	}
	return merged;
}

function flatten(linkedList) {
	//console.log(linkedList)
	//merge 2 items adjacent items, then move on to the next one.
	let flattenedList = linkedList.head.value;
	let nextListToMerge = linkedList.head.next;

	if (flattenedList === null) return linkedList;

	while(nextListToMerge) {
		//pass 2 linkedLists into merged
		flattenedList = merge(flattenedList, nextListToMerge.value);
		nextListToMerge = nextListToMerge.next;
	}
	return flattenedList;



	//edge cases: empty list, only one item in the list, what happens when you're on the last 2 items.
}


//DUPLICATE NUMBER
function duplicateNumber(array) {
	let options = [];
	for (let i = 0; i < array.length - 1; i++) {
		options.push(i);
	}
	let returnNumber;
	
	array.forEach(number => {
		if (options.indexOf(number) == -1) returnNumber = number;;
		const index = options.indexOf(number);
		options.splice(index, 1)
	})
	return returnNumber;
};

function duplicateNumberTwo(array) {
	//the array is essentially 0...n-2 + the duplicatedNumber
	let expectedSum = 0;
	let actualSum = 0;

	for (let i = 1; i < array.length - 1; i++) {
		expectedSum += i;
	}

	array.forEach(num => actualSum += num);

	return actualSum - expectedSum
};

function maxSumSubarray (array) {
	let currentMax = 0;
	let currentSum = 0;

	array.forEach(number => {
		currentSum = Math.max(currentSum + number, 0);
		currentMax = Math.max(currentSum, currentMax);
	})
	return currentMax;
}

function FibonacciTriangle(height) {
	if (height === 0) return 0;

	let currentRow = [1];
	for (let i = 1; i < height; i++) {
		let newRow = [1];
		for (let j = 0; j < currentRow.length - 1; j++) {
			newRow.push(currentRow[j] + currentRow[j+1])
		}
		newRow.push(1);
		currentRow = newRow;
	}
	return currentRow;
};

function even_after_odd(head) {
	let evenHead = null;
	let evenTail = null;
	let oddHead = null;
	let oddTail = null;

	let currentEval = head;
	while(currentEval) {
		if(currentEval.value % 2 === 0) {
			if (!evenHead) {
				evenHead = currentEval;
				evenTail = evenHead;
			} else {
				evenTail.next = currentEval;
				evenTail = evenTail.next
			}
		} else {
			if (!oddHead) {
				oddHead = currentEval;
				oddTail = oddHead
			} else {
				oddTail.next = currentEval;
				oddTail = oddTail.next
			}
		}
		currentEval = currentEval.next
	}	
	oddTail.next = evenHead;

	return head;
};

function skipIDeleteJ(head, i, j) {
	let currentNode = head;
	let newNext;

	while(currentNode) {
		// currentNode = false;
		for (let skip = 1; skip < i; skip++) {
				if (!currentNode) break;
				currentNode = currentNode.next
		}
		newNext = currentNode;
		for (let remove = 0; remove <= j; remove++) {
				if (!currentNode || !newNext) break;
				newNext = newNext.next;			
		} 
		currentNode.next = newNext;
		currentNode = newNext;
	}
	return head
};


class Stack {
	constructor() {
		this.items = [];
	}

	size() {
		return this.items.length;
	}	

	push(item) {
		this.items.push(item)
	}

	pop() {
		if (this.size === 0) return null;
		return this.items.pop();
	}
};

function equationChecker(string) {
	let parenthesesStack = new Stack();

	for (let i = 0; i < string.length; i++) {
		if (string[i] === '(') parenthesesStack.push('+');
		else if (string[i] === ')') parenthesesStack.pop();
	}
	return parenthesesStack.size() === 0 ? true: false;
}

function reverseStack (stack) {
	let reversedStack = new Stack();

	while (stack.size()) {
		const item = stack.pop();
		reversedStack.push(item);
	}
	return reversedStack;
} 

function sumIntegers(n) {
	if (n === 0) return 0;
	if (n === 1) {
		return 1;
	} else {
		return n + sumIntegers(n - 1);
	}
}

function factorial(n) {
	if (n === 1) {
		return 1;
	} else {
		return n * factorial(n - 1)
	}
}

const reverseString = (str) => {
	if (str) {
		let tempString = reverseString(str.substr(1)) + str[0];
		return tempString;
	} else {
		return str
	}
};

const isPalindrome = (str) => {
	if (str.length <= 1) {
		return true
	} else {
		const subString = str.slice(1, str.length - 1);
		const firstChar = str[0];
		const lastChar = str[str.length - 1];

		return (firstChar === lastChar && isPalindrome(subString))
	}
}

console.log(isPalindrome('racecars'));



</script>
	
</body>
</html>