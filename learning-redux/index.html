<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>ToDos/Goals</title>
</head>
<body>

	<div id='app'></div>

	<script src='https://unpkg.com/react@16.8.3/umd/react.development.js'></script>
	<script src='https://unpkg.com/react-dom@16.8.3/umd/react-dom.development.js'></script>
	<script src='https://unpkg.com/babel-standalone@6.15.0/babel.min.js'></script>
	<script src='https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js'></script>
	<script src='https://tylermcginnis.com/goals-todos-api/index.js'></script>
	<script src='https://unpkg.com/redux-thunk@2.2.0/dist/redux-thunk.min.js'></script>
	<script src='https://unpkg.com/react-redux@6.0.1/dist/react-redux.js'></script>
	<script type='text/babel'>

		//generate unique ID for actions
		function generateId () {
		  return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
		}

		//reducers
		function todos (state = [], action) {
			switch (action.type) {
				case 'ADD_TODO' :
					return state.concat([action.todo]);
				case 'REMOVE_TODO' :
					return state.filter( todo => todo.id !== action.id );	
				case 'TOGGLE_TODO' :
					return state.map( todo => todo.id !== action.id ? todo : 
						Object.assign({}, todo, {completed: !todo.completed})
					)
				case 'RECEIVE_DATA': 
					return action.todos

				default: return state
			}
		}

		function goals (state = [], action) {
			switch (action.type) {
				case 'ADD_GOAL' :
					return state.concat([action.goal]);
				case 'REMOVE_GOAL' :
					return state.filter( goal => goal.id !== action.id);
				case 'RECEIVE_DATA' :
					return action.goals
				default: return state
			}
		}

		function loading (state = true, action) {
			switch (action.type) {
				case 'RECEIVE_DATA' :
					return false
				default: return state;
			}
		}

		//Action functions

		function handleInitialData () {
			return (dispatch) => {
				Promise.all([
				  API.fetchTodos(),
				  API.fetchGoals()
				]).then( ([todos, goals]) => {
					dispatch(receiveDataAction(todos, goals))
				})
			}
		}

		function receiveDataAction (todos, goals) {
			return {
				type: 'RECEIVE_DATA',
				todos,
				goals

			}
		}

		function handleAddTodo (value, func) {
			return (dispatch) => {
				return API.saveTodo(value)
					.then( (todo) => {
						dispatch(addTodoAction(todo))
						func()
					})
					.catch( () => alert('Oops. An error has occurred!'));
			}
		}

		function addTodoAction (todo) {
			return {
				type: 'ADD_TODO',
				todo
			}
		}

		function handleDeleteTodo (todo) {
			return (dispatch) => {
				dispatch(removeTodoAction(todo.id));

				API.deleteTodo(todo.id)
				  .catch( () => {
					dispatch(addTodoAction(todo));
					alert('Oops. An error has occurred!');
					})
			}
		}

		function removeTodoAction (id) {
			return {
				type: 'REMOVE_TODO',
				id
			}
		}

		function handleToggleTodo (todo) {
			return (dispatch) => {
				dispatch(toggleTodoAction(todo.id));

				API.saveTodoToggle (todo.id)
					.catch( () => {
						dispatch(toggleTodoAction(todo.id));
						alert('Oops. An error has occurred!');
					})
			}
		}

		function toggleTodoAction (id) {
			return {
				type: 'TOGGLE_TODO',
				id
			}
		}

		function handleAddGoal (value, func) {
			return (dispatch) => {
				return API.saveGoal(value)
				.then( (goal) => {
					dispatch(addGoalAction(goal))
					func()
				})
				.catch( () => alert('Oops. An error has occurred!'));
			}
		}

		function addGoalAction (goal) {
			return {
				type: 'ADD_GOAL',
				goal
			}
		}

		function handleDeleteGoal (goal) {
			return (dispatch) => {
				dispatch(removeGoalAction(goal.id))

				API.deleteGoal(goal.id)
					.catch( () => {
						dispatch(addGoalAction(goal));
						alert('Oops. An error has occurred!');
					})
			}
		}

		function removeGoalAction (id) {
			return {
				type: 'REMOVE_GOAL',
				id
			}
		}

		//middleware

		const checker = (store) => (next) => (action) => {
			if (action.type === "ADD_TODO" &&
				action.todo.name.toLowerCase().indexOf('tron') !== -1
			) {
				alert('That is a terrible idea');
			}
			if (action.type === "ADD_GOAL" &&
				action.goal.name.toLowerCase().indexOf('tron') !== -1
			) {
				alert('That is a terrible idea');
			}
			return next(action)
		}

		const logger = (store) => (next) => (action) => {
			console.group(action.type)
			console.log('The action: ', action);
			const result = next(action);
			console.log('The new state: ', store.getState())
			console.groupEnd()

			return result;
		}

		//initiate store
		const store = Redux.createStore(Redux.combineReducers({
			todos,
			goals,
			loading
		}), Redux.applyMiddleware(ReduxThunk.default, checker, logger));

		//react components

		class Loading extends React.Component {
			constructor (props) {
				super (props);

				this.state = {text: 'Loading'}
			}

			componentDidMount () {
				const stopper = 'Loading...'

				this.counter = setInterval( () => {
					this.state.text !== stopper 
						? this.setState({
						text: this.state.text + '.'
						}) 
						: this.setState({
						text: 'Loading'
						})
				}, 200)
			}

			componentWillUnmount () {
				clearInterval(this.counter)
			}

			render () {			
				return (
				<h3>{this.state.text}</h3>
				)
			}
		}

		function List (props) {

			return (
				<ul>
					{props.items.map( item => (
						<li key={item.id}>
							<span onClick={ () => props.toggleItem && props.toggleItem(item)}
								  style={item.completed ? {textDecoration: 'line-through'} : {textDecoration: 'none'}} >
								{item.name}
							</span>
							<button onClick={ () => props.removeItem(item)}>X</button>
						</li>

					))}
				</ul>
			)
		}

		class Todos extends React.Component {

			addItem = (e) => {
				e.preventDefault();
				this.props.dispatch(handleAddTodo(
					this.input.value,
					() => this.input.value = '' 
				))
			}

			removeItem = todo => {
				this.props.dispatch(handleDeleteTodo(todo));
			}

			toggleItem = todo => {
				this.props.dispatch(handleToggleTodo(todo))
			}

			render () {
				return (
					<div>
						<h1>Todos</h1>
						<input 
							placeholder='Add Todo'
							type='text'
							ref={(input) => this.input = input}
						/>
						<button onClick={this.addItem}>
							Add ToDo
						</button>
						<List items={this.props.todos}
							  removeItem = {this.removeItem}
							  toggleItem={this.toggleItem}/>
					</div>
				)
			}
		}

		const ConnectedTodos = ReactRedux.connect( (state) => ({
			todos: state.todos
		}))(Todos)

		class Goals extends React.Component {

			addItem = (e) => {
				e.preventDefault();
				this.props.dispatch(handleAddGoal(
					this.input.value,
					() => this.input.value = ''
				))
			}

			removeItem = item => {
				this.props.dispatch(handleDeleteGoal(item));
			}

			render () {
				return (
					<div>
						<h1>Goals</h1>
						<input 
							placeholder='Add Goal'
							type='text'
							ref={(input) => this.input = input}
						/>
						<button onClick={this.addItem}>
							Add Goal
						</button>
						<List items={this.props.goals}
							  removeItem={this.removeItem}/>
					</div>
				)
			}
		}

		const ConnectedGoals = ReactRedux.connect( (state) => ({
			goals: state.goals
		}))(Goals)

		class App extends React.Component {

			componentDidMount () {
				this.props.dispatch(handleInitialData())
			}

			render() {

				const {loading} = this.props

				if (loading) {
					return <Loading />
				}

				return (
					<div>
						<ConnectedTodos />
						<ConnectedGoals />
					</div>
				)
			}
		}

		const ConnectedApp = ReactRedux.connect( (state) => ({
			loading: state.loading
		}))(App)

		ReactDOM.render(
			<ReactRedux.Provider store={store}>
				<ConnectedApp />
			</ReactRedux.Provider>, 
		document.getElementById('app')
		);

	</script>

</body>
</html>